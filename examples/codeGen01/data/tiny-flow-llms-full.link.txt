# tiny-workflow Documentation for LLMs

> The `tiny-workflow` library provides a lightweight, portable workflow engine inspired by Temporal.io. It allows you to write long-running, persistent, and pausable business logic as a single piece of TypeScript code using the core package `@tiny-json-workflow/runtime-durable-state`.

This document provides a comprehensive guide for an AI agent coder to understand and use the `tiny-workflow` package.

---

### Table of Contents

1.  [Overview](#overview)
2.  [Core Concepts](#core-concepts)
3.  [Getting Started: Running Your First Workflow](#getting-started-running-your-first-workflow)
4.  [Authoring Workflows: The Generated Code Pattern](#authoring-workflows-the-generated-code-pattern)
5.  [Key API Methods](#key-api-methods)
6.  [Advanced Patterns](#advanced-patterns)
    - [Orchestrating Long-Running Jobs (DAGs)](#advanced-pattern-orchestrating-long-running-jobs-dags)
    - [Creating Interactive Workflows (Client-Server)](#advanced-pattern-creating-interactive-workflows-client-server)
7.  [API Reference](#api-reference)
8.  [Examples](#examples)

---

## Overview

**tiny-workflow** is designed to be a simpler, more portable alternative to powerful workflow engines like Temporal. It requires only basic components to run and is built entirely in TypeScript. The core runtime is available via the NPM package `@tiny-json-workflow/runtime-durable-state`.

### Core Principles

- **Code-Driven**: Workflows are defined as TypeScript classes that control the sequence of operations.
- **Separation of Concerns**: The workflow's _control flow_ (the sequence and conditions for steps) is separated from the _business logic_ (the tasks that perform the work).
- **Serializable & Portable**: The entire state of a workflow can be serialized to a single JSON object. This allows you to store the workflow state in any database and resume it later, even on a different machine.
- **Resilient**: Actions within a step are cached using `withAction` to prevent re-execution on resume.

---

## Core Concepts

The entire workflow is built around the `DurableState` class, imported from `@tiny-json-workflow/runtime-durable-state`.

### The `DurableState` Class

This is the foundation of any workflow. You create your own workflow class by extending `DurableState`.

It has three important generic type arguments:

1.  `EStep`: A string enum that defines all possible steps in your workflow.
2.  `TStateShape`: A TypeScript type that defines the shape of your persistent state (`this.state`).
3.  `EAuditLog`: A string union type for custom log messages you want to record.

```typescript
import { DurableState } from "@tiny-json-workflow/runtime-durable-state";

// Define custom log types
export type MyAuditLog = "user_registered" | "profile_updated";

export class YourWorkflow extends DurableState<EStep, TStateShape, MyAuditLog> {
  // ... implementation
  myMethod() {
    // Add a custom, structured log entry
    this.addLog({
      type: "user_registered",
      values: { userId: this.state.userId },
    });
  }
}
```

### Steps

Steps are the building blocks of your workflow's logic. Each step is an `async` generator method within your workflow class. The name of the method must correspond to a member of your `EStep` enum. The workflow engine executes these steps in sequence.

A step function's signature looks like this:
`private async *"my_step_name"(): StepIt<EStep, EStep.next_step_name>`

> Important. the function name must be same with EStep value

You `return { nextStep: EStep.next_step_name }` to transition, or `{ nextStep: null }` to end the workflow.

### State (`this.state`)

The `state` property holds all the data for your workflow that needs to persist across pauses and resumptions. It is a simple JavaScript object that must conform to the `TStateShape` you defined.

### Persistence (Save/Load)

Workflows are designed to be saved and loaded easily.

- `instance.toJSON()`: Serializes the entire workflow instance into a JSON object.
- `YourWorkflowClass.fromJSON(YourWorkflowClass, data)`: A static method to restore a workflow instance from its serialized JSON data. The constructor is passed as the first argument to allow the static method to correctly instantiate the specific workflow subclass.

---

## Getting Started: Running Your First Workflow

This is the basic structure for setting up a runtime and executing a workflow.

1.  **Define or import your workflow class**: This is typically done using the [Generated Code Pattern](#authoring-workflows-the-generated-code-pattern).
2.  **Set up the context and runtime**: `SimpleContext` is an in-memory store for workflow states. `WorkflowRuntime` orchestrates the execution.
3.  **Create and run an instance**: Instantiate your workflow, set its initial state, and pass it to `runtime.run()`.
4.  **Handle the result**: The result indicates if the workflow finished, encountered an error, or needs to be resumed later (e.g., for a timer).

```typescript
// This code would consume the generated 'createWorkflow' factory
import {
  SimpleContext,
  WorkflowRuntime,
} from "@tiny-json-workflow/runtime-durable-state";
import { createWorkflow, UserOnboardingFlow } from "./.generated-workflow"; // Your generated file

async function main() {
  const ctx = new SimpleContext();
  const runtime = new WorkflowRuntime({
    ctx,
    genRunId: async () => `user-onboarding-${Date.now()}`,
    InstanceClass: UserOnboardingFlow, // Pass the class constructor
  });

  const onboardingFlow = createWorkflow();
  // Set initial state if needed
  onboardingFlow.setState({ userId: "user-123", profileIsComplete: false });

  // Run the workflow
  let result = await runtime.run(onboardingFlow);

  // Handle the workflow's outcome
  switch (result.status) {
    case "need_resume":
      {
        console.log(`Workflow paused. Resume info:`, result.resumeEntry);
        // If the workflow is waiting for a timer, the context can schedule it
        if (result.resumeEntry.type == "timer")
          await ctx.scheduleNextRun(result.runId, result);
      }
      break;
    case "error":
      console.error("Workflow failed:", result.error);
      break;
    case "finished":
      console.log("Workflow finished successfully.");
      break;
  }

  // ... wait for all background tasks to finish
  await ctx.runner.idle();

  // Bonus: Load the final state data by its RunId
  const runData = await ctx.load(result.runId);
  console.log("Final state:", runData?.state);
}
```

---

## Authoring Workflows: The Generated Code Pattern

The recommended way to create a workflow is by using a code generator that scaffolds a file separating the workflow's control flow from its implementation logic.

[Attachments section](#example-examplesflowssimplets)

The generated file has two parts:

1.  **GENERATED**: This section contains the `DurableState` class that defines the workflow's structure, steps, and transitions. **You should not edit this part manually.**
2.  **IMPLEMENTATION**: This section contains stub functions for the actual business logic (Tasks). **This is where you write your code.**

### The Generated Workflow File Structure

Based on the reference template, a generated workflow file looks like this:

```typescript
// doc/_ref/.generated-workflow.ts

// -----------------
// --- GENERATED ---
// -----------------
import {
  DurableState,
  type StepIt,
} from "@tiny-json-workflow/runtime-durable-state";

// 1. Enums and Types for Steps and State
export enum EStep {
  StartFlow = "StartFlow"
  SendWelcome = "SendWelcome",
  SendReminder = "SendReminder",
}
export type TStateShape = {
  /*
    infer from json
    added properties outside json flow put into key
    _extra : {....}
   */
};

// 2. A 'Tasks' type defining the business logic functions
export type Tasks = {
  SendWelcome: (context: TStateShape, params: any) => Promise<TStateShape>;
  SendReminder: (context: TStateShape) => Promise<TStateShape>;
};

// 3. The DurableState class defining the control flow
export class UserOnboardingFlow extends DurableState<EStep, TStateShape, any> {
  constructor(private tasks: Tasks) {
    // default step ( aka begin step)
    super(EStep.StartFlow);

    // Make sure register all EStep(s) and coresponding handler
    this.stepHandler.set(EStep.SendWelcome, this.SendWelcome.bind(this));
    // ....
  }

  // 4. Step methods
  private async *SendWelcome(): StepIt<EStep, EStep.CheckProfile> {
    const res = await this.withAction<TStateShape>("SendWelcome", async () => {
      // Delegates to the injected task implementation
      return this.tasks.SendWelcome(this.state, undefined);
    });

    if (res.it) yield res.it;
    if (res.value) this.state = res.value; // Update state with the task's result
    return { nextStep: EStep.CheckProfile };
  }
  // ... other steps ...
}

// --- IMPLEMENTATION ---

// 5. Your part: Implement the task functions
async function SendWelcome(
  context: TStateShape,
  params: any
): Promise<TStateShape> {
  console.log(`Sending welcome email to user ${context.userId}...`);
  // TODO: Implement task 'Send Welcome Email'
  return context; // Return the new state
}
// ... other tasks ...

// 6. A factory to wire it all together
export function createWorkflow() {
  return new UserOnboardingFlow({
    SendWelcome,
    SendReminder,
  });
}
```

This pattern separates the _what_ from the _how_: the `UserOnboardingFlow` class defines the order of operations, while the `SendWelcome` function defines how to perform one of those operations.

---

## Key API Methods

These methods are used inside your `DurableState` class methods.

### `withAction<T>(key, action)`

Executes and caches a function, ensuring it runs only once even if the workflow is resumed. In the generated pattern, this is used to call your task implementations. The `action`'s return value should be the new state object, which then updates `this.state`.

### `waitForMs(key, duration)`

Pauses the workflow for a specified duration (in milliseconds).

```typescript
// Inside a step method:
const wait = this.waitForMs("wait_a_day", 24 * 60 * 60 * 1000);
if (wait.it) yield wait.it; // This pauses the workflow
// This code runs only after the delay has passed and the workflow is resumed.
```

### `waitForEvent<T>(key, requestPayload)`

Pauses the workflow to wait for external data, such as user input. The workflow remains paused at this point until `resolveResume(resumeId, payload)` is called externally with the corresponding `resumeId`.

```typescript
// Inside a step method for an interactive workflow:
const { it, value } = this.waitForEvent<number>("get_user_guess", {
  question: "Guess a number between 1 and 100",
});
if (it) yield it; // Pauses here

const userGuess = value(); // The value provided by resolveResume()
```

---

## Advanced Patterns

### Advanced Pattern: Orchestrating Long-Running Jobs (DAGs)

For complex workflows with parallel tasks or dependencies (a Directed Acyclic Graph), a simple `withAction` is not ideal for long-running jobs. The recommended **"Start and Poll"** pattern separates task initiation from completion checking.

- **`doStart`**: A non-blocking function that triggers an external task (e.g., a batch job).
- **`pollStatus`**: A function that checks if the task is done, which the workflow calls periodically.

This pattern is highly resilient. The status of all tasks is stored in the workflow's state, so it can be saved, loaded, and resumed at any point, and polling will continue where it left off. The full source code for this pattern is available in the [Attachments section](#example-examplesflowsdagtaskts) below.

### Advanced Pattern: Creating Interactive Workflows (Client-Server)

Workflows can be designed to react to external events (like user actions or API calls) while they are running. This pattern separates the workflow "server" (the running process) from the "client" (the interactor).

1.  **Define Action Methods**: These are public methods on your workflow class that can be called from outside the workflow's execution loop. They typically modify the workflow's state.
2.  **Use `withTransaction`**: To prevent race conditions when updating the workflow from an external client, the `SimpleContext` provides a `withTransaction` helper. It locks the workflow state, loads the latest instance, executes your action, and saves the updated state automatically.

The workflow, upon its next execution (e.g., after a `waitForMs` timer completes), can then read its updated state and change its control flow accordingly. The full source code for this pattern is available in the [Attachments section](#example-examplesflowsintervalpaymentts) below.

---

## Attachments

### Typedef for package @tiny-json-workflow/runtime-durable-state

> Copy from npmPackage [https://www.npmjs.com/package/@tiny-json-workflow/runtime-durable-state?activeTab=code]

```typescript
export type ContinueTrigger =
  | {
      type: "time";
      resumeId: string;
      resumeAt: number;
    }
  | {
      type: "event";
      resumeId: string;
    };
export type DurableStateIterator<T> = {
  canContinue: boolean;
  activeStep: T;
  resumeTrigger?: ContinueTrigger;
};
export type DurableStateReturn<StateShape> = {
  isEnd: boolean;
  finalState: StateShape;
};
export type ExeOpt = {
  ignoreCache?: boolean;
  maxRetry?: number;
};
export type TimerSystemEntry = {
  type: "timer";
  resumeId: string;
  isDone: boolean;
  resumeAfter: number;
  responsePayload?: any;
};
export type EventSystemEntry = {
  type: "event";
  resumeId: string;
  isDone: boolean;
  requestPayload?: any;
  responsePayload?: any;
};
export type DurableStateSystemEntry = TimerSystemEntry | EventSystemEntry;
export type StepIt<EStep, MoveToStep> = AsyncIterator<
  DurableStateIterator<EStep>,
  {
    nextStep: MoveToStep | null;
  }
>;
export type StepHandler<EStep> = () => StepIt<EStep, EStep>;
export type AuditLogEntry<S, EStep> = {
  type:
    | "init"
    | "cache"
    | "transition"
    | "interrupt_begin"
    | "interrupt_end"
    | "action_error"
    | S;
  values: Record<string, any>;
  _at?: number;
  _step?: EStep;
};
export declare const SystemAuditLogType: string[];
export type DurableStateOpt = {
  withAuditLog: boolean;
  debug?: boolean;
};
export type Constructor<T> = new (...args: any[]) => T;
export type SnapshotType<T extends DurableState> = ReturnType<T["toJSON"]>;
export declare class DurableState<
  EStep = any,
  StateShape = Record<string, any>,
  ExtAuditLogType = any
> {
  private opt?;
  private step;
  private cache;
  private system;
  private logs;
  protected state: StateShape;
  protected stepHandler: Map<EStep, StepHandler<EStep>>;
  protected runId?: string;
  constructor(defaultStep?: EStep, opt?: DurableStateOpt | undefined);
  setState(state: StateShape): void;
  /** Current step */
  get currentStep(): EStep;
  /** Clone of audit logs */
  get auditLogs(): AuditLogEntry<ExtAuditLogType, EStep>[];
  /** Clone of current state */
  get currentState(): StateShape;
  /** Sequence number. It increa everytime state change */
  get stepSeq(): any;
  /** Prefix for system and cache key - prevent conflict in case a step visit multiple times */
  protected get stepKeyPrefix(): string;
  /** Find resumeEntry by Id - return a cloned */
  getResume(resumeId: string): DurableStateSystemEntry | null;
  /** list all pending resumeEntries - return a cloned list */
  listPendingResume(): DurableStateSystemEntry[];
  /** resole a resume entry */
  resolveResume(resumeId: string, payload?: any): void;
  exec(
    runId?: string
  ): AsyncGenerator<
    DurableStateIterator<EStep>,
    DurableStateReturn<StateShape> | null
  >;
  private _moveToStep;
  protected withAction<TRes = any>(
    key: string,
    action: () => Promise<any>,
    opt?: ExeOpt
  ): Promise<{
    it?: DurableStateIterator<EStep>;
    value: TRes | undefined;
  }>;
  protected waitForMs(
    key: string,
    timeoutMs: number
  ): {
    it?: DurableStateIterator<EStep>;
    value: () => number | undefined;
  };
  protected waitForEvent<TRes = any>(
    key: string,
    requestPayload: any
  ): {
    it?: DurableStateIterator<EStep>;
    value: () => TRes | undefined;
  };
  protected genResumeId(key: string): string;
  protected nowMs(): number;
  protected addLog(itm: AuditLogEntry<ExtAuditLogType, EStep>): void;
  protected _debug(...args: any[]): void;
  private canRetry;
  toJSON(): {
    step: EStep;
    state: StateShape;
    cache: Record<string, any>;
    system: Record<string, DurableStateSystemEntry>;
    logs: AuditLogEntry<ExtAuditLogType, EStep>[];
  };
  static fromJSON<
    EStep,
    ShapeState,
    ExtAuditLogType,
    T extends DurableState<EStep, ShapeState, ExtAuditLogType>
  >(
    type: Constructor<T>,
    data: {
      step: EStep;
      state: ShapeState;
      cache?: Record<string, any>;
      system?: Record<string, DurableStateSystemEntry>;
      logs?: AuditLogEntry<ExtAuditLogType, EStep>[];
    },
    opt?: DurableStateOpt
  ): T;
}
export declare class MicroTaskRunner {
  private pendingTasks;
  private resolved;
  addTask(
    task: Promise<any>,
    opts?: {
      runId: string;
    }
  ): Promise<any>;
  reset(): void;
  stats(): {
    total: number;
    done: number;
  };
  /** waiting for all pending tasks settled */
  idle(): Promise<void>;
}
export type WorkflowRuntimeOpt<T extends DurableState> = {
  ctx: IRuntimeContext<T>;
  genRunId: () => Promise<string>;
  InstanceClass: Constructor<T>;
};
export interface IRuntimeContext<T extends DurableState> {
  attachRuntime(runtime: WorkflowRuntime<T>): void;
  save(runId: string, snapshotData: SnapshotType<T>): Promise<void>;
  load(runId: string): Promise<SnapshotType<T> | null>;
  lock(runId: string): Promise<void>;
  unlock(runId: string): Promise<void>;
}
export type WorkflowRunResult =
  | {
      runId: string;
      status: "need_resume";
      resumeEntry: DurableStateSystemEntry;
    }
  | {
      runId: string;
      status: "finished";
    }
  | {
      runId: string;
      status: "error";
      error?: any;
    };
export declare class WorkflowRuntime<T extends DurableState> {
  private opts;
  constructor(opts: WorkflowRuntimeOpt<T>);
  get ctx(): IRuntimeContext<T>;
  run(ins: T, runId?: string): Promise<WorkflowRunResult>;
  resume(
    runId: string,
    {
      resumeId,
      resumePayload,
    }: {
      resumeId: string;
      resumePayload?: any;
    }
  ): Promise<WorkflowRunResult>;
  createInstanceByRunId(runId: string, Cons: Constructor<T>): Promise<T>;
}
export declare class MemoryLock {
  readonly promise: Promise<void>;
  private resolve;
  constructor();
  unlock(): void;
  wait(): Promise<void>;
}
export declare class SimpleContext<T extends DurableState>
  implements IRuntimeContext<T>
{
  readonly runner: MicroTaskRunner;
  runtime: WorkflowRuntime<T>;
  db: Map<string, SnapshotType<T>>;
  dbLock: Map<string, MemoryLock>;
  attachRuntime(runtime: WorkflowRuntime<T>): void;
  lock(runId: string): Promise<void>;
  unlock(runId: string): Promise<void>;
  save(runId: string, snapshotData: SnapshotType<T>): Promise<void>;
  load(runId: string): Promise<SnapshotType<T> | null>;
  start(): Promise<void>;
  shutdown(): Promise<void>;
  withTransaction(runId: string, action: () => Promise<void>): Promise<void>;
  scheduleNextRun(runId: string, result: WorkflowRunResult): Promise<void>;
}

export {};
```

### Example: examples/flows/simple.ts

```ts
import {
  DurableState,
  type StepIt,
  SimpleContext,
  WorkflowRuntime,
} from "@tiny-json-workflow/runtime-durable-state";

// -----------------
// --- GENERATED ---
// -----------------

export enum EStep {
  StartFlow = "start-flow",
  SendWelcome = "send-welcome",
  CheckProfile = "check-profile",
  SendReminder = "send-reminder",
  EndFlow = "end-flow",
}

export type TStateShape = {
  userId: string;
  profileIsComplete?: boolean;
};

export type Tasks = {
  SendWelcome: (
    state: TStateShape,
    params: { template?: string }
  ) => Promise<TStateShape>;
  SendReminder: (state: TStateShape) => Promise<TStateShape>;
};

export class UserOnboardingFlow extends DurableState<EStep, TStateShape, any> {
  constructor(private tasks: Tasks) {
    super(EStep.StartFlow);
    this.stepHandler.set(EStep.StartFlow, this.StartFlow.bind(this));
    this.stepHandler.set(EStep.SendWelcome, this.SendWelcome.bind(this));
    this.stepHandler.set(EStep.CheckProfile, this.CheckProfile.bind(this));
    this.stepHandler.set(EStep.SendReminder, this.SendReminder.bind(this));
    this.stepHandler.set(EStep.EndFlow, this.EndFlow.bind(this));
  }

  private async *StartFlow(): StepIt<EStep, EStep.SendWelcome> {
    console.log("[Workflow] Starting Onboarding Flow");
    return { nextStep: EStep.SendWelcome };
  }

  private async *SendWelcome(): StepIt<EStep, EStep.CheckProfile> {
    const params = { template: "welcome-email-v2" };
    const res = await this.withAction<TStateShape>("SendWelcome", async () => {
      return this.tasks.SendWelcome(this.state, params);
    });
    if (res.it) yield res.it;
    if (res.value) this.state = res.value;
    return { nextStep: EStep.CheckProfile };
  }

  private async *CheckProfile(): StepIt<
    EStep,
    EStep.EndFlow | EStep.SendReminder
  > {
    console.log(
      `[Workflow] Checking profile for user ${this.state.userId}. Profile Complete: ${this.state.profileIsComplete}`
    );
    if (this.state.profileIsComplete === true) {
      return { nextStep: EStep.EndFlow };
    } else {
      return { nextStep: EStep.SendReminder };
    }
  }

  private async *SendReminder(): StepIt<EStep, EStep.EndFlow> {
    const res = await this.withAction<TStateShape>("SendReminder", async () => {
      return this.tasks.SendReminder(this.state);
    });
    if (res.it) yield res.it;
    if (res.value) this.state = res.value;
    return { nextStep: EStep.EndFlow };
  }

  private async *EndFlow(): StepIt<EStep, null> {
    console.log("[Workflow] Ending Onboarding Flow");
    return { nextStep: null };
  }
}

// --- IMPLEMENTATION ---

async function SendWelcome(
  state: TStateShape,
  params: { template?: string }
): Promise<TStateShape> {
  console.log(
    `[Task] Sending welcome email with template: ${params.template} to user ${state.userId}...`
  );
  await new Promise((resolve) => setTimeout(resolve, 100));
  return { ...state };
}

async function SendReminder(state: TStateShape): Promise<TStateShape> {
  console.log(`[Task] Sending profile reminder to user ${state.userId}...`);
  await new Promise((resolve) => setTimeout(resolve, 100));
  return { ...state };
}

export function createWorkflow() {
  return new UserOnboardingFlow({
    SendWelcome,
    SendReminder,
  });
}

// --- Main Execution Logic ---

async function main() {
  const ctx = new SimpleContext();
  const runtime = new WorkflowRuntime({
    ctx,
    genRunId: async () => `user-onboarding-${Date.now()}`,
    InstanceClass: UserOnboardingFlow,
  });

  // Scenario 1: Profile is complete
  const onboardingFlowComplete = createWorkflow();
  onboardingFlowComplete.setState({
    userId: "001",
    profileIsComplete: true,
  });

  console.log("--- Starting Workflow (Profile Complete) ---");
  let resultComplete = await runtime.run(onboardingFlowComplete);

  switch (resultComplete.status) {
    case "need_resume":
      console.log(`Workflow paused. Resume info:`, resultComplete.resumeEntry);
      break;
    case "error":
      console.error("Workflow failed:", resultComplete.error);
      break;
    case "finished":
      console.log("Workflow finished successfully.");
      break;
  }
  await ctx.runner.idle();
  let runDataComplete = await ctx.load(resultComplete.runId);
  console.log("Final state (Profile Complete):", runDataComplete?.state);

  // Scenario 2: Profile is incomplete
  const onboardingFlowIncomplete = createWorkflow();
  onboardingFlowIncomplete.setState({
    userId: "002",
    profileIsComplete: false,
  });

  console.log("\n--- Starting Workflow (Profile Incomplete) ---");
  let resultIncomplete = await runtime.run(onboardingFlowIncomplete);

  switch (resultIncomplete.status) {
    case "need_resume":
      console.log(
        `Workflow paused. Resume info:`,
        resultIncomplete.resumeEntry
      );
      break;
    case "error":
      console.error("Workflow failed:", resultIncomplete.error);
      break;
    case "finished":
      console.log("Workflow finished successfully.");
      break;
  }
  await ctx.runner.idle();
  let runDataIncomplete = await ctx.load(resultIncomplete.runId);
  console.log("Final state (Profile Incomplete):", runDataIncomplete?.state);
}

main();
```

### Example: examples/flows/dagTask.ts

```typescript
import { DurableState, type StepIt } from "tiny-workflow-core/src";
import { setTimeout } from "node:timers/promises";
import assert from "node:assert";

enum EStep {
  step_begin = "step_begin",
  step_process = "step_process",
  step_end = "step_end",
}

export type TaskInfo<T = Record<string, any>, IDType = string> = {
  id: IDType;
  status?: "waiting" | "processing" | "end";
  ctx?: T;
};

export type TaskSequence<T = any, IDType = string> = TaskInfo<T, IDType>[];

export type TStateShape = Partial<{
  sequences: TaskSequence[];
}>;

// additional audit log message
type EAuditLog = "start_hit" | "end_hit";

export type TaskDagHandler<D = any, K = string> = {
  doStart: (itm: TaskInfo<D, K>) => Promise<void>;
  pollStatus: (itm: TaskInfo<D, K>) => Promise<TaskInfo["status"]>;
};

class DagTaskEngine extends DurableState<EStep, TStateShape, EAuditLog> {
  constructor(private logicHandler: TaskDagHandler) {
    super(EStep.step_begin, {
      withAuditLog: false,
      debug: false,
    });

    // collect and resgister all step handler
    Object.values(EStep).map((step) =>
      this.stepHandler.set(step, this[step].bind(this))
    );
  }

  updateLogicHandler(logicHandler: TaskDagHandler) {
    this.logicHandler = logicHandler;
  }

  setState(state: TStateShape) {
    this.state = state;
  }

  override exec(runId?: string) {
    if (!this.logicHandler) throw new Error("missing logicHandler");

    return super.exec();
  }

  private async *step_begin(): StepIt<EStep, EStep.step_process> {
    return { nextStep: EStep.step_process };
  }

  private async *step_process(): StepIt<
    EStep,
    EStep.step_end | EStep.step_process
  > {
    const sequences = this.state.sequences ?? [];

    const tasks = sequences.map((chain) => this._processOneChain(chain));

    while (!this.allDone) {
      const res = await Promise.allSettled(tasks.map((itm) => itm.next()));
      const errors = res.filter((itm) => itm.status === "rejected");
      if (errors.length !== 0) {
        throw new Error(
          `Got errors: ${JSON.stringify(
            errors.map((err) => {
              return {
                message: err?.reason?.message,
                stackTrace: err?.reason?.stack,
              };
            })
          )}`
        );
      }

      yield {
        canContinue: false,
        activeStep: EStep.step_process,
      };
    }

    return { nextStep: EStep.step_end };
  }

  private async *step_end(): StepIt<EStep, null> {
    return { nextStep: null };
  }

  private async *_processOneChain(chain: TaskInfo[]) {
    for (let i = 0; i < chain.length; i++) {
      const itm = chain[i];
      if (itm.status === "end") continue;

      const isWaiting = itm.status === "waiting" || itm.status === undefined;
      if (isWaiting) {
        await this.logicHandler.doStart(itm);
        itm.status = "processing";
        itm.ctx = itm.ctx || {};
        itm.ctx.startTime = Date.now();
        this.addLog({
          type: "start_hit",
          values: {
            id: itm.id,
          },
        });
      }

      // poll
      if (itm.status === "processing") {
        const nextStatus = await this.logicHandler.pollStatus(itm);
        itm.status = nextStatus;
        if (nextStatus === "end") {
          itm.ctx = itm.ctx || {};
          itm.ctx.endTime = Date.now();
          this.addLog({
            type: "end_hit",
            values: {
              id: itm.id,
            },
          });
          continue;
        }
      }

      yield;
      i--;
    }
  }

  public get allDone() {
    const sequences = this.state.sequences ?? [];
    return sequences.every(this.isOneChainDone);
  }

  private isOneChainDone(chain: TaskInfo[]) {
    return chain.every((itm) => itm.status === "end");
  }
}

//------------------------------
//  Helper
//------------------------------

function buildSequence<T = any, K = string>() {
  const sequence: TaskSequence<T, K> = [];
  const ins = {
    build() {
      return sequence;
    },
    isEmpty() {
      return sequence.length === 0;
    },
    next(taskInfo: TaskInfo<T, K>) {
      sequence.push(taskInfo);
      return ins;
    },
  };
  return ins;
}

async function main() {
  /*
    Simulate sequence task

    t1_1 -> t1_2 -> t1_3
    t2_1
    t3_1 -> t3_2 -> t3_3

    Should finish when all tasks done
  */
  const taskState: TStateShape = {
    sequences: [
      // c1
      buildSequence()
        .next({
          id: "t1_1",
          ctx: {
            _doneAt: Date.now() + 1000,
          },
        })
        .next({
          id: "t1_2",
          ctx: {
            _doneAt: Date.now() + 2000,
          },
        })
        .next({
          id: "t1_3",
          ctx: {
            _doneAt: Date.now() + 3000,
          },
        })
        .build(),

      // c2
      buildSequence()
        .next({
          id: "t2_1",
          ctx: {
            _doneAt: Date.now() + 2000,
          },
        })
        .build(),
      // c3
      buildSequence()
        .next({
          id: "t3_1",
          ctx: {
            _doneAt: Date.now() + 1000,
          },
        })
        .next({
          id: "t3_2",
          ctx: {
            _doneAt: Date.now() + 5000,
          },
        })
        .build(),
    ],
  };

  // simulate pool workflow
  const handler: TaskDagHandler = {
    doStart: async (itm: TaskInfo) => {
      // do nothing
      console.info("start task ", itm.id);
    },
    pollStatus: async (itm: TaskInfo) => {
      const _doneAt = itm.ctx?.["_doneAt"] ?? 0;
      let status: TaskInfo["status"] = "processing";
      if (Date.now() > _doneAt) {
        status = "end";
      }

      console.info("pool task ", itm.id, "->", status);
      return status;
    },
  };

  async function _runMaxIter(ins: DagTaskEngine, maxIter: number) {
    for await (const it of ins.exec()) {
      maxIter--;
      if (maxIter <= 0) return false;

      const breakTime = 500;
      console.log(`\t take a break. poll again after ${breakTime} ms`);
      // console.dir(ins.currentState.sequences, { depth: 10 });
      await setTimeout(breakTime);
    }
    return true;
  }

  let ins: DagTaskEngine;
  let data;

  // 1st run. only 2 iter
  console.log("------------------------");
  console.log("Run only 2 iter");
  console.log("------------------------");

  {
    ins = new DagTaskEngine(handler);
    ins.setState(taskState);
    await _runMaxIter(ins, 2);
    data = ins.toJSON();
  }

  console.log("------------------------");
  console.log("SIMULATE SAVE / LOAD");
  console.log("Resume after 5 sec");
  console.log("------------------------");

  await setTimeout(5000);

  // load and resume
  {
    ins = DagTaskEngine.fromJSON(DagTaskEngine, data);
    ins.updateLogicHandler(handler);

    const res = await _runMaxIter(ins, 1000);

    assert(res === true, "Something wrong");
  }

  console.log("allDone:", ins.allDone);
  console.dir(ins.toJSON(), { depth: 10 });
}

main();
```

### Example: examples/flows/intervalPayment.ts

```typescript
import { join } from "path";
import {
  DurableState,
  SimpleContext,
  WorkflowRuntime,
  type StepHandler,
  type StepIt,
  type WorkflowRuntimeOpt,
} from "tiny-workflow-core/src";

enum EStep {
  step_begin = "step_begin",
  step_wait = "step_wait",
  step_send_receipt = "step_send_receipt",
  step_cancel = "step_cancel",
  step_end = "step_end",
}

type UsageItem = {
  item: string;
  amount: number;
};
type ReceiptItem = {
  cycle: number;
  createdAt: number;
  usages: UsageItem[];
  deliveryId?: string;
};
type TStateShape = {
  userEmail: string;
  paymentIntervalMs: number;

  _cycle: number;
  _nextPaymentAt: number;

  status: "active" | "cancel";
  currentUsages: UsageItem[];

  receipts: Array<ReceiptItem>;
};
type EAuditLog = "set_param" | "add_usage" | "bill_sent" | "cancel";

class IntervalPaymentFlow extends DurableState<EStep, TStateShape, EAuditLog> {
  // Type Safeguard & Auto register
  private _static(key: EStep): StepHandler<EStep> {
    return this[key];
  }
  private _collectAndRegisterSteps() {
    Object.values(EStep).map((step) =>
      this.stepHandler.set(step, this._static(step).bind(this))
    );
  }
  constructor() {
    super(EStep.step_begin, {
      withAuditLog: false,
      debug: true,
    });
    this._collectAndRegisterSteps();
  }

  setParam(tmp: Pick<TStateShape, "userEmail" | "paymentIntervalMs">) {
    this.state = { ...this.state, ...tmp };
    this.addLog({
      type: "set_param",
      values: {
        ...tmp,
      },
    });
  }

  actionAddUsage(usageItem: UsageItem) {
    if (this.state.status != "active")
      throw new Error("status is not active. can not process");

    this.state.currentUsages.push({ ...usageItem });
    this.addLog({
      type: "add_usage",
      values: {
        ...usageItem,
      },
    });
  }

  actionCancel() {
    if (this.state.status != "active")
      throw new Error("status is not active. can not process");

    this.state.status = "cancel";

    this.addLog({
      type: "cancel",
      values: {},
    });
  }

  private async *step_begin(): StepIt<EStep, EStep.step_wait> {
    this.state = {
      ...this.state,
      ...{
        status: "active",
        _cycle: 0,
        _nextPaymentAt: Date.now() + this.state.paymentIntervalMs,
        currentUsages: [],
        receipts: [],
      },
    };
    return { nextStep: EStep.step_wait };
  }

  private async *step_wait(): StepIt<
    EStep,
    EStep.step_cancel | EStep.step_send_receipt
  > {
    while (this.state.status === "active") {
      const cycle_no = this.state._cycle;
      const needToWaitMs = this.state._nextPaymentAt - Date.now();
      const res = this.waitForMs(
        `wait_for_end_cycle_${cycle_no}`,
        needToWaitMs
      );
      if (res.it) {
        this._debug("wait for cycle_no=", cycle_no);
        yield res.it;
      }

      if (this.state.status !== "active") {
        return { nextStep: EStep.step_cancel };
      }

      this.state._cycle = this.state._cycle + 1;
      this.state._nextPaymentAt = Date.now() + this.state.paymentIntervalMs;
      this._debug(
        "inc cycle_no=",
        this.state._cycle,
        "nextCheck=",
        this.state._nextPaymentAt
      );

      // have any usage
      if (this.state.currentUsages.length > 0) {
        const receipt: ReceiptItem = {
          cycle: cycle_no,
          createdAt: Date.now(),
          usages: [...this.state.currentUsages],
        };
        this.state.receipts.push(receipt);
        this.state.currentUsages = [];

        return { nextStep: EStep.step_send_receipt };
      }
    }

    return { nextStep: EStep.step_cancel };
  }

  private async *step_send_receipt(): StepIt<
    EStep,
    EStep.step_wait | EStep.step_end
  > {
    const lastReceipt = this.state.receipts.at(-1);
    const cycle_no = lastReceipt?.cycle;
    if (!lastReceipt) throw new Error("lastReceipt is null");

    const res = await this.withAction<string>(
      `send_receipt_email_${cycle_no}`,
      async () => {
        const deliveryId = Date.now().toString(32);
        this._debug(
          `Send bill for cycle_no=${cycle_no} to email=${
            this.state.userEmail
          }, receipt=${JSON.stringify(lastReceipt)}`
        );

        this.addLog({
          type: "bill_sent",
          values: {
            receipt: { ...lastReceipt },
          },
        });
        return deliveryId;
      }
    );

    if (res.it) {
      yield res.it;
    }
    if (res.value) lastReceipt.deliveryId = res.value;

    if (this.state.status === "active") return { nextStep: EStep.step_wait };
    else return { nextStep: EStep.step_end };
  }

  private async *step_cancel(): StepIt<
    EStep,
    EStep.step_end | EStep.step_send_receipt
  > {
    const cycle_no = this.state._cycle;

    // any usage ?
    if (this.state.currentUsages.length > 0) {
      const receipt: ReceiptItem = {
        cycle: cycle_no,
        createdAt: Date.now(),
        usages: [...this.state.currentUsages],
      };
      this.state.receipts.push(receipt);
      this.state.currentUsages = [];

      return { nextStep: EStep.step_send_receipt };
    }

    return { nextStep: EStep.step_end };
  }

  private async *step_end(): StepIt<EStep, null> {
    return { nextStep: null };
  }
}

class MemContext<T extends DurableState> extends SimpleContext<T> {
  async lock(runId: string) {
    await super.lock(runId);
    console.info("\x1b[34m", `[ üîí ] - ${runId}`, "\x1b[0m");
  }

  async unlock(runId: string) {
    await super.unlock(runId);
    console.info("\x1b[34m", `[ üóùÔ∏è ] - ${runId}`, "\x1b[0m");
  }

  async shutdown() {
    await super.shutdown();
    await this.syncDBToFile();
  }

  async syncDBToFile() {
    const savePath = join(__dirname, "./tmp/intervalPayment_db.json");
    Bun.write(savePath, JSON.stringify([...this.db.entries()], null, " "));
    console.log("db synced: ", savePath);
  }
}

async function main() {
  const ctx = new MemContext<IntervalPaymentFlow>();
  let count = 0;
  const opt: WorkflowRuntimeOpt<IntervalPaymentFlow> = {
    ctx,
    genRunId: async () => `r_${count++}`,
    InstanceClass: IntervalPaymentFlow,
  };
  new WorkflowRuntime<IntervalPaymentFlow>(opt);
  await ctx.start();

  const ins = new IntervalPaymentFlow();
  ins.setParam({
    userEmail: "info@company.com",
    paymentIntervalMs: 10_000,
  });

  // Unique runId per user
  const runId = `run_${ins.currentState.userEmail}`;

  // Workflow run on server side
  await ctx.runner.addTask(runBackground(runId, ctx, ins), {
    runId,
  });

  // User terminal interface
  ctx.runner.addTask(runFrontend(runId, ctx), {
    runId,
  });

  await ctx.runner.idle();
  console.log("all done");

  await ctx.shutdown();
}
main();

async function runBackground(
  runId: string,
  ctx: MemContext<IntervalPaymentFlow>,
  ins: IntervalPaymentFlow
) {
  let tmp = await ctx.runtime.run(ins, runId);
  ctx.runner.addTask(ctx.scheduleNextRun(runId, tmp), {
    runId,
  });
  return runId;
}

async function runFrontend(
  runId: string,
  ctx: MemContext<IntervalPaymentFlow>
) {
  const usage = `
  /state:         print state as json
  /add [num]:     add a random usage. default num=1
  /save:          save storage to file
  /cancel:        cancel
  /exit:          exit
  `;
  console.log(`ü§ü Wellcome ${"info@company.com"} to IntervalPayment ü§ü`);
  console.log(usage);

  type cmdType = "/state" | "/add" | "/save" | "/exit" | "/cancel";

  for await (const line of console) {
    const tmp = line.trim().split(" ");
    const cmd = tmp[0] as cmdType;
    const args = tmp.slice(1);

    switch (cmd) {
      case "/state":
        {
          const ins = await ctx.runtime.createInstanceByRunId(
            runId,
            IntervalPaymentFlow
          );
          console.log({
            step: ins.currentStep,
            state: ins.currentState,
            runtimeUsage: ctx.runner.stats(),
          });
        }
        continue;
      case "/add": {
        {
          const sample = parseInt(args[0] ?? "1");

          ctx.withTransaction(runId, async () => {
            const ins = await ctx.runtime.createInstanceByRunId(
              runId,
              IntervalPaymentFlow
            );
            for (let i = 0; i < sample; i++) {
              const item = `id_${Math.round(Math.random() * 100)}`;
              const amount = Math.round(Math.random() * 10);
              ins.actionAddUsage({
                item,
                amount,
              });
              console.log(`add usage ${item} - ${amount}`);
            }
          });
        }
        continue;
      }

      case "/save":
        {
          ctx.syncDBToFile();
          console.log("saved");
        }
        continue;

      case "/cancel":
        {
          ctx.withTransaction(runId, async () => {
            const ins = await ctx.runtime.createInstanceByRunId(
              runId,
              IntervalPaymentFlow
            );
            ins.actionCancel();
            console.log("canceled");
          });
        }
        return;

      case "/exit":
        console.log("exit!");
        process.exit(0);

      default:
        console.log(usage);
    }
  }
}
```
